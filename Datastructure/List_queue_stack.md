### 链表

链表作为一种最基础的数据结构，有着非常广泛的用途，因此其考察频率也相对较高。单一的链表作为知识点本身难度并不大，文中会列举出我在学习链表过程中遇到过的有意思的题目以及相对热门的面试考点。

***

1. 反转单链表

   反转单链表是十分高频的考题，做之前，简要介绍下链表常用的两种插入方法——头插与尾插。顾名思义，假设有一个链表的头节点head，尾节点tail，待插入节点p，头插法即将p指向head所指向的后继节点，再让head指向p；尾插法则是让尾节点指向p，再将p赋值给tail并修改next指针为空即可。

   要对链表进行反转，梳理下思路，假设有节点node，反转时只需后移一步，再指向前驱节点即可。移动后node需要指向前驱节点，也即移动前node的位置，因此需要额外引入指针pre来保存node的初始节点信息。node指向前驱节点的操作完成后，需知道后继节点才能向后移动，因此还需引入指针fol，在node移动前记录后继节点信息。

   ```c++
   //循环法实现
   void ReverseList(List *&head)
   {
       List *cur = nullptr ;//被操作节点
       List *fol = head ;//后继节点信息
       List *pre ;//前驱节点信息
       head->next = nullptr ;//头节点反转后为尾，需置为空指针
       while(fol != nullptr)
       {
           pre = cur ;
           cur = fol ;
           fol = fol->next ;
           cur->next = pre ;
       }
       head = cur ;
   }
   ```

   当然也可以用递归来实现，递归的思路就是从后向前推理，先找出终止条件（递归退出条件），显然本题的终止条件为遍历到空节点。

   ```c++
   //递归实现
   List ReverseList(List *head)
   {
       if(head->next == nullptr || head == nullptr)
           return head;
       List *temp = head->next ;//记录下个节点
       List *phead = ReverseList(temp) ;//先将下个节点带入递归
       temp->next = head ;//更改下个节点的指针
       head->next = nullptr ;//反转后头节点在尾部，需修改为空指针
       return phead ;
   }
   ```

   综上，反转单链表的两种方法就完成了。方法一使用静态函数，并直接在原链表上修改，操作完成后head依旧指向新的头节点。而方法二中，由于需要返还值来获取节点信息，故需定义为链表函数。

2. 如何检测单链表有环

   本题在C/C++、数据结构等相关知识提问环节出现的概率极高。首先要明白题意，单链表是只有一个后继指针的，记得曾和一位朋友交流时，他回答此题是可以直接遍历所有节点，因为存在环，故必然有节点存在两个后继指针导致分叉......这显然是理解层面上的反面教材。言归正传，检测单链表有环的方法网上应该可以查到不少，我能想到的最好理解的应该就是双指针法。
   设想下有一个环形操场，张三与李四站在起点处，哨声一响，两人同时出发，张三的速度为v，李四的速度是张三的两倍（或多倍），那么在运动距离上李四一定是领先张三的，而由于操场为环形，李四一定会再次与张三相遇，且相遇时领先的距离恰好等于操场的周长。那么反过来讲，速度不同，只要李四能与张三相遇（起点不算），就证明操场是一定环形的。这就是双指针的含义，指针ptr1以每次一个节点的速度移动，指针ptr2以每次两个（或多个）节点的速度移动，如果二者在后续能够相遇（即ptr1 == ptr2 || ptr1->next == ptr2），则可以证明该单链表存在环。

3. 链表与数组

   考题里常会问到链表与数组的优劣，其实属于常识类问题，稍微巩固一下数据结构的基础部分都不会有问题。

   数组的优点是可以随机存取，查改便利，当数组的规模非常大时会明显优于链表。数组的缺陷也很大，例如在进行插入或删除时会进行数据的大量拷贝，而链表只需通过节点指针的修改即可完成增删操作，再例如，数组存储数据是在连续的物理块上，而链表由于指针的缘故并没有此要求，所以数组会在一定程度上造成存储空间的浪费。
